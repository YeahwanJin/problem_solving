1번
중간에 부분합, max, min 등등에서 갱신이 필요하면 세그먼트 트리가 유리
덧셈트리로 잘 구현하기

어레이: 100만
1. 덧셈트리 만드는 함수: ex) K값 받기, A[i]=(A[2i]+A[2i+1])로 역순으로 반복문 채우기
2. 갱신함수: logN-> A[k], A[[k/2]]... 갱신
3. 덧셈연산함수: 한줄에 2개까지만 참조
long long sum=0; s,e보고 더해야 하는 노드 찾아 더하기, 끝나면 출력
* N!=2^k이면 가까운 k 찾아서 A[2^(k-1)]부터 채운다.

논리:
1. N이상의 가장 작은 2^k 찾기: k 반복문으로 찾기, 2^k가 2N보다 같거나 커지면 종료.
2. i,v 받았을 때 i=N+i, A[i]=v; /A[[i/2]]=A[[i/2]*2]+A[[i/2]*2+1];, i--; -> j=k, j>00/
3. 받은 수열 인덱스: i=1-N-1
4. 수열: 1-N, 트리내에서의 인덱스: 2^(k-1)~2^(k-1)+N, i번쨰-> 2^(k-1)+i
5. 덧셈연산
s=2^(k-1)+s
처음에 s,e 같을 때
반복: while s!=e => 교환법칙 성립x
s짝e홀: s=[s/2], e=[e/2]
s짝e짝: sum=sum+A[e], s=[s/2], e=[e/2]
s홀e홀: sum=sum+A[s], s=[s/2]+1, e=[e/2]
s홀e짝: sum=sum+A[s]+A[e], s=[s/2]+1, e=[e/2]



구조:
변수선언: N, k
어레이 선언: long long A[백만]
-> global(다른 함수에서 대입 없이 사용)

널 프린터

덧셈트리 함수(N, 수열)

갱신함수(i, v)

구간합 함수(s,e)

main
변수선언: int q
N입력
k 찾기
수열 입력받기
덧셈트리 함수 실행
쿼리 행 입력 반복
q값에 따라 실행
s=N+s
e=N+e


