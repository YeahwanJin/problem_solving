
1. ㄱ자를 채우는 루틴: 모양 관리, k관리 해서 잘 맞추기
2.왼쪽 위 칸, 변의 길이, 비어있는칸

w#1
1. 세그먼트 트리: 미리 배열을 짤라놓는 방법/ 재귀호출: 1-7->1-3, 4-7->1, 2-3, 4-5, 6-7 -> 3,4,5 
-> 구간합에서 노드를 왼쪽, 오른쪽에서 오면서 선택: 교환법칙이 성립이 안됨 // 왼쪽합, 오른쪽합 따로 관리하기: if s%2==1, if e%2==1
교환법칙이 성립하지 않는 세그먼트 트리
덧셈에서 0은 항등원, ans=f(ans, arr[e]) // s+=N; e+=N, sml=id , smr= id, 루프불변 답: f(sml,sme, smr), if(s%2==1) sml=f(sml, arr[s++]) if(e%2==1) smr=f(arr[e--],smr), s/=1, e/=2
왜 s+N인가?
2. (()), ()(): 스택에 (or)를 받기, 여는괄호: 넣기, 닫는괄호: 짝 맺기->스택에서 뺴주기, 닫는괄호: 무시, 여는괄호 스택 넣기-> 짝을 진 괄호들만 문자열에 넣으면 가장 긴 문자열을 얻음

pair: 2    pair: 1
open: 1  pair: 0
close: 0  pair: 1 
3+1
1-1
1-1

m=min(lo,r.c)

3. 새로운 diag가 들어올 때마다 기존의 diag을 스캔하고 교점을 센다. a-c, b-d면 a<b<c<d or b,a<d<c: 수직선 상에서 생각하기
for문으로 추가된 교점의 개수 구하기, 
subtask3: a<x<b<y or x<a<y<b인 경우 세기: 2차원에 ab구간을 x,y축에 표시. 영역이 생기고 여기에 1값을 저장함. 1값이 찍히는 횟수를 구하는 문제로 바뀜. 
x,y-r,c까지의 영역 누적합: 0-r,c에서  0-r,y 0-x,c를 빼고 0-x,y를 더하기

2차원 테이블 만들고 갱신: r,c를 갱신할 때 rth row를 바꾸기

5. 카이스트 사진관.
같은 수에 -, +를 교대로 붙여서 구간합을 구하기.-> 갱신처리x
xor을 처리하기. 교환및 결합법칙이 성립됨. 0^x=x, x^x=0

6. 오른쪽에서 볼 때 나와 걔 사이에 최댓값이 있을 때 어디까지 볼 수 있는가. 모노토닉 스택을 사용해 입력값보다 작은애는 pop, 입력값을 push.